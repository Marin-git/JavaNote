[TOC]
### 1. 进程
#### 1.1 进程死亡原因
- Java应用程序的问题：发生OOM导致进程Crash
- JVM出现错误：JVM或JDK自身的BUG导致进程Crash
- 操作系统OOM：Killer

##### 1.1.1 应用程序发生OOM排查步骤
1. 查看JVM参数 -XX:+HeapDumpOnOutOfMemoryError 和-XX:HeapDumpPath=*/java.hprof； 
2. 根据HeapDumpPath指定的路径查看是否产生dump文件；
3. 若存在dump文件，使用Jhat、VisualVM等工具分析即可；

##### 1.1.2 JVM发生致命错误
- 当jvm发生致命错误时，会生成一个错误文件hs_err_pid.log，其中包括了导致jvm crash的重要信息，可以通过分析hs_err_pid.log定位导致crash的根源

##### 1.1.3 操作系统进行OOM-Killer
1. 查看操作系统日志：sudo grep –color “java” /var/log/messages，确定Java进程是否被操作系统Kill； 
2. 若被操作系统Kill，执行dmesg命令查看系统各进程资源占用情况，明确Java占用内存是否合理，以及是否有其它进程不合理的占用了大量内存空间；

#### 1.2 进程概念
进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态的概念，竞争计算机系统资源的基本单位，每一个进程都有一个自己的地址空间，即进程空间。
进程有五种状态：初始太、执行态、等待状态、就绪状态、终止状态
### 2. 线程
#### 2.1 线程死亡的原因
- run() 或者 call() 方法执行完成，线程正常结束
- 线程抛出一个未捕获的Exception或Error
- 直接调用该线程的stop()方法来结束该线程

#### 2.2 线程概念
线程是进程的一部分，一个没有线程的进程可以被看做是一个单线程。线程是CPU调度的一个基本单位

-------

## 3、如何提高并发性

- 提高cpu并发计算能力
  1、 多进程&多线程

  2、减少上下文切换

  3、 减少锁

  4、 进程优先级

  5、 关注系统负载   

- 改进I/O模型

  1、 DMA技术

  2、 异步I/O

  3、 改进多路I/O就绪通知策略， epoll

  4、Sendfile

  5、内存映射

  6、直接I/O

----

##  4、CPU比较高的原因

1、首先查看是哪些进程的CPU占用率最高（如下可以看到详细的路径）

ps -aux --sort -pcpu | more

\# 定位有问题的线程可以用如下命令

ps -mp pid -o THREAD,tid,time | more

2、查看JAVA进程的每个线程的CPU占用率

ps -Lp 5798 cu | more    # 5798是查出来进程PID

3、追踪线程，查看负载过高的原因，使用JDK下的一个工具

jstack 5798            # 5798是PID

jstack -J-d64 -m 5798    # -j-d64指定64为系统

jstack 查出来的线程ID是16进制，可以把输出追加到文件，导出用记事本打开，再根据系统中的线程ID去搜索查看该ID的线程运行内容，可以和开发一起排查。

---

##  5、死锁、解决死锁的策略

1、互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。

2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

3、不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。

4、循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。



解决方法：银行家算法

1、预防死锁:属于事前预防的策略，通过设置某些限制条件，去破坏产生死锁的四个必要条件或其中的几个条件。预防死锁比较容易实现，所以被泛使用，但是由于施加的限制条件过于严格可能会导致系统资源利用率和系统吞吐量降低。

2、避免死锁:属于事前预防的策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的产生。但实现有一定的难度。目前较完善的系统中常用此法来避免死锁。

3、检测死锁:这种方法不需要事前采取任何限制措施，也不用检查是否进入不安全状态，而是允许系统在运行的过程中发生死锁。但是通过系统所设置的检测机构.及时的检测出死锁的发生，并精确的测出与死锁有关的进程和资源，然后，采取适当的措施，从系统中将已发生的死锁清楚掉。

4、解除死锁:这是与检测死锁相配套的一套措施。当检测到系统已经产生死锁时，须将进程从死锁中解放出来。通常用到的实施方法是撤销或挂起些进程，以便收回一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源和吞吐量，但在现实上难度也最大。

5、预防死锁和避免死锁的区别:预防死锁和避免死锁实质上都是通过施加某种相知条件的方法，来预防发生死锁。两者的主要区别:为了预防死锁所施加的限制条件较为严格，这往往会影响到进程的并发执行，而避免死锁所施加的限制条件则较为宽松，有利于进程的并发执行。

------



