[TOC]
----

#### 触发器的作用
触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

----
#### 什么是存储过程？用什么来调用
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。

----
#### 存储过程与函数的区别
**存储过程**
1. 用于在数据库中完成特定的操作或者任务（如插入、删除等）
2. 程序头部声明用procedure
3. 程序头部声明时不需描述返回类型可以使用in/out/in out 三种模式的参数
4. 可作为一个独立的PL/SQL语句来执行
5. 可以通过out/in out 返回零个或多个值
6. SQL语句(DML 或SELECT)中不可调用存储过程

**函数**
1. 用于特定的数据（如选择）
2. 程序头部声明用function
3. 程序头部声明时要描述返回类型，而且PL/SQL块中至少要包括一个有效的return语句
4. 可以使用in/out/in out 三种模式的参数
5. 不能独立执行，必须作为表达式的一部分调用
6. 通过return语句返回一个值，且改值要与声明部分一致，也可以是通过out类型的参数带出的变量
7. SQL语句(DML 或SELECT)中可以调用函数

----
#### 索引的作用，它的优缺点是什么
索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。
适合建索引的字段：唯一、不为空、经常被查询的字段

----
#### 索引类型
1. 逻辑上
- Single column 单行索引
- Concatenated 多行索引
- Unique 唯一索引
- NonUnique 非唯一索引
- Function-based 函数索引
- Domain 域索引
2. 物理上
- Partitioned 分区索引
- NonPartitioned  非分区索引
3. B-tree
- Normal  正常型B树
- Rever Key  反转型B树 Bitmap 位图索引

----
#### 事务和锁
$\color{yellow}{事务}$就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 $\color{yellow}{锁}$：在所以的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。

----
#### 视图
$\color{yellow}{优点}$：
1. 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。
2. 用户通过简单的查询可以从复杂查询中得到结果。
3. 维护数据的独立性，试图可从多个表检索数据。
4. 对于相同的数据可产生不同的视图。
$\color{yellow}{缺点}$：
- 查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

---- 
#### 数据库查询优化
1. 建索引
2. 减少表之间的关联
3. 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 
4. 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据
5. 尽量用PreparedStatement来查询，不要用Statement

---

#### MySQL日志文件
1. **重做日志**（redo log）
- 作用：确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
- 内容：物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。

- 产生时间：事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。

- 释放时间：当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。

- 对应的物理文件：默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&ib_logfile2  
innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。  
innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2

- 关于文件的大小和数量，由以下两个参数配置：  
innodb_log_file_size 重做日志文件的大小。  
innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1

- 其他：很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。  
之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。

- 会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘  
    1. Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
    2. 每个事务提交时会将重做日志刷新到重做日志文件。
    3. 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件  

    由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。


2. **回滚日志**（undo log）
- 作用：保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

- 内容：逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

- 产生时间：事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性

- 释放时间：当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

- 对应的物理文件：  
MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。  
MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数

- 其他：undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。
默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。

3. **二进制日志**（binlog）
- 作用：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。

- 内容：逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。在使用mysqlbinlog解析binlog之后一些都会真相大白。因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。

- 产生时间：事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。这是因为binlog是在事务提交的时候一次性写入的造成的

- 释放时间：binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。

- 对应的物理文件：配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。

- 其他：二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同  
作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。  
内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句  
另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。  
恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog  
关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。

4. **错误日志**（errorlog）

5. **慢查询日志**（slow query log）

6. **一般查询日志**（general log）

7. **中继日志**（relay log）

---
#### 分布式柔性事务
   

   


